# -------------------------------------------------------------------------------------------------#
#                                                                                                  #
#  _   _                     _   _  __         ___   _____  _     _                  __ _          #
# | | | |_ _  __ _ _ _  _ __| |_(_)/ _|_  _   / __| / / __|| |_ _| |_   __ ___ _ _  / _(_)__ _     #
# | |_| | ' \/ _| '_| || (_-<  _| |  _| || | | (__ / / (_|_   _|_   _| / _/ _ \ ' \|  _| / _` |    #
#  \___/|_||_\__|_|  \_,_/__/\__|_|_|  \_, |  \___/_/ \___||_|   |_|   \__\___/_||_|_| |_\__, |    #
#                                      |__/                                              |___/     #
#                                                                                                  #
# -------------------------------------------------------------------------------------------------#
#                                                                                                  #
# Style: rindeal                                                                                   #
#                                                                                                  #
# -------------------------------------------------------------------------------------------------#
# Boilerplate: https://github.com/bengardner/uncrustify/blob/master/etc/defaults.cfg               #
# -------------------------------------------------------------------------------------------------#


## General
## -------------------------------------------------------------------------------------------------

# The type of line endings
newlines                                = lf     # auto/lf/crlf/cr

# - 80 limit is completely deprecated
# - 100 is the new soft limit
# - 120 is hard limit
code_width                              = 0

# empty_lines_max                       = nl_max - 1
nl_max                                  = 3


## UNICODE
## -------------------------------------------------------------------------------------------------
## Ideally ASCII, UTF-8 otherwise

# If the file contains bytes with values between 128 and 255, but is not UTF-8, then output as UTF-8
utf8_byte                               = false

# Force the output encoding to UTF-8
utf8_force                              = true


## Tabs
## -------------------------------------------------------------------------------------------------
## Always use 4 spaces

input_tab_size                          = 4
output_tab_size                         = 4

indent_with_tabs                        = 0

# Comments that are not a brace level are indented with tabs on a tabstop.
# Requires indent_with_tabs=2. If false, will use spaces.
indent_cmt_with_tabs                    = false

# Whether to use tabs for aligning
align_with_tabs                         = false

# Whether to keep non-indenting tabs
align_keep_tabs                         = false

# Whether to bump out to the next tab when aligning
align_on_tabstop                        = false


## Indenting
## -------------------------------------------------------------------------------------------------

# The number of columns to indent per level.
# Usually 2, 3, 4, or 8.
indent_columns                          = 4

# The continuation indent. If non-zero, this overrides the indent of '(' and '=' continuation indents.
# For FreeBSD, this is set to 4. Negative value is absolute and not increased for each ( level
indent_continue                         = 2


## Spacing
## -------------------------------------------------------------------------------------------------

# Whether to balance spaces inside nested parens
sp_balance_nested_parens                = false


## Parentheses
## -------------------------------------------------------------------------------------------------

# Controls the indent of a close paren after a newline.
# 0: Indent to body level
# 1: Align under the open paren
# 2: Indent to the brace level
indent_paren_close                      = 2


## Preprocessor
## -------------------------------------------------------------------------------------------------

# Control indent of preprocessors inside #if blocks at brace level 0
pp_indent                               = remove    # ignore/add/remove/force

# indent by 1 space
pp_space                                = add
pp_space_count                          = 1

# indent pp at code level
pp_indent_at_level                      = true # maybe false?
pp_define_at_level                      = true # maybe false?

# Control whether to indent the code between #if, #else and #endif when not at file-level
pp_if_indent_code                       = false

# # Align macro functions and variables together
align_pp_define_together                = false

# The minimum space between label and value of a preprocessor define
align_pp_define_gap                     = 1

# The span for aligning on '#define' bodies (0=don't align)
align_pp_define_span                    = 2

# Add or remove space around preprocessor '##' concatenation operator. Default=Add
sp_pp_concat                            = add       # ignore/add/remove/force

# Add or remove space after preprocessor '#' stringify operator. Also affects the '#@' charizing operator.
sp_pp_stringify                         = ignore    # ignore/add/remove/force

# Add or remove space before preprocessor '#' stringify operator as in '#define x(y) L#y'.
sp_before_pp_stringify                  = ignore    # ignore/add/remove/force


# Template
# --------------------------------------------------------------------------------------------------

# Add or remove space in 'template <' vs 'template<'.
# If set to ignore, sp_before_angle is used.
sp_template_angle                       = add     # ignore/add/remove/force

# Add or remove space before '<>'
sp_before_angle                         = remove  # ignore/add/remove/force

# Add or remove space inside '<' and '>'
sp_inside_angle                         = remove  # ignore/add/remove/force

# Add or remove space after '<>'
sp_after_angle                          = add     # ignore/add/remove/force

# Add or remove space between '<>' and '(' as found in 'new List<byte>();'
sp_angle_paren                          = remove  # ignore/add/remove/force

# Add or remove space between '<>' and a word as in 'List<byte> m;'
sp_angle_word                           = add     # ignore/add/remove/force

# Add or remove space between '>' and '>' in '>>' (template stuff C++/C# only). Default=Add
sp_angle_shift                          = add     # ignore/add/remove/force


# Whether to indent strings broken by '\' so that they line up
indent_align_string                     = true

# Whether braces are indented to the body level
indent_braces                           = false
# Disabled indenting function braces if indent_braces is true
indent_braces_no_func                   = false
# Disabled indenting class braces if indent_braces is true
indent_braces_no_class                  = false
# Disabled indenting struct braces if indent_braces is true
indent_braces_no_struct                 = false
# Indent based on the size of the brace parent, i.e. 'if' => 3 spaces, 'for' => 4 spaces, etc.
indent_brace_parent                     = false
# Whether the 'namespace' body is indented
indent_namespace                        = true
# Whether the 'extern "C"' body is indented
indent_extern                           = false
# Whether the 'class' body is indented
indent_class                            = true
# Whether to indent the stuff after a leading base class colon
indent_class_colon                      = false # maybe true?
# False=treat 'else\nif' as 'else if' for indenting purposes
# True=indent the 'if' one level
indent_else_if                          = false
# Indent continued variable declarations instead of aligning.
indent_var_def_cont                     = true

# True:  indent continued function call parameters one indent level
# False: align parameters under the open paren
indent_func_call_param                  = false
# Same as indent_func_call_param, but for function defs
indent_func_def_param                   = false
# Same as indent_func_call_param, but for function protos
indent_func_proto_param                 = false
# Same as indent_func_call_param, but for class declarations
indent_func_class_param                 = false
# Same as indent_func_call_param, but for class variable constructors
indent_func_ctor_var_param              = false
# Same as indent_func_call_param, but for templates
indent_template_param                   = false
# Double the indent for indent_func_xxx_param options
indent_func_param_double                = true

# If set, will indent trailing single line ('//') comments relative
# to the code instead of trying to keep the same absolute column
indent_relative_single_line_comments    = false
# Whether to indent comments found in first column
indent_col1_comment                     = true
# Indent the code after an access specifier by one level.
# If set, this option forces 'indent_access_spec=0'
indent_access_spec_body                 = false
# If an open paren is followed by a newline, indent the next line so that it lines up after the open paren (not recommended)
indent_paren_nl                         = false
# Controls the indent of a comma when inside a paren.If TRUE, aligns under the open paren
indent_comma_paren                      = false
# Controls the indent of a BOOL operator when inside a paren.If TRUE, aligns under the open paren
indent_bool_paren                       = false
# If 'indent_bool_paren' is true, controls the indent of the first expression. If TRUE, aligns the first expression to the following ones
indent_first_bool_expr                  = false
# If an open square is followed by a newline, indent the next line so that it lines up after the open square (not recommended)
indent_square_nl                        = false
# Don't change the relative indent of ESQL/C 'EXEC SQL' bodies
indent_preserve_sql                     = false
# Align continued statements at the '='. Default=True
# If FALSE or the '=' is followed by a newline, the next line is indent one tab.
indent_align_assign                     = true

# Whether to left-align numbers
align_number_left                       = true
# Align variable definitions in prototypes and functions
align_func_params                       = true
# Align parameters in single-line functions that have the same name.
# The function names must already be aligned with each other.
align_same_func_call_params             = true
# Whether to align the colon in struct bit fields
align_var_def_colon                     = true
# Whether to align any attribute after the variable name
align_var_def_attribute                 = true
# Whether to align inline struct/enum/union variable definitions
align_var_def_inline                    = true
# If aligning comments, mix with comments after '}' and #endif with less than 3 spaces before the comment
align_right_cmt_mix                     = false
# Align function protos on the 'operator' keyword instead of what follows
align_on_operator                       = false
# Whether to mix aligning prototype and variable declarations.
# If true, align_var_def_XXX options are used instead of align_func_proto_XXX options.
align_mix_var_proto                     = false
# Align single-line functions with function prototypes, uses align_func_proto_span
align_single_line_func                  = true
# Aligning the open brace of single-line functions.
# Requires align_single_line_func=true, uses align_func_proto_span
align_single_line_brace                 = true
# Whether to align macros wrapped with a backslash and a newline.
# This will not work right if the macro contains a multi-line comment.
align_nl_cont                           = false
# Align lines that start with '<<' with previous '<<'. Default=True
align_left_shift                        = true
# Aligning parameters in an Obj-C '+' or '-' declaration on the ':'
align_oc_decl_colon                     = false
# Whether to collapse empty blocks between '{' and '}'
nl_collapse_empty_body                  = true

# Don't split one-line braced assignments - 'foo_t f = { 1, 2 };'
nl_assign_leave_one_liners              = true    # false/true
# Don't split one-line braced statements inside a class xx { } body
nl_class_leave_one_liners               = true    # false/true
# Don't split one-line enums: 'enum foo { BAR = 15 };'
nl_enum_leave_one_liners                = true    # false/true
# Don't split one-line get or set functions
nl_getset_leave_one_liners              = true    # false/true
# Don't split one-line function definitions - 'int foo() { return 0; }'
nl_func_leave_one_liners                = true    # false/true
# Don't split one-line C++11 lambdas - '[]() { return 0; }'
nl_cpp_lambda_leave_one_liners          = true    # false/true
# Don't split one-line if/else statements - 'if(a) b++;'
nl_if_leave_one_liners                  = true    # false/true
# Don't split one-line while statements - 'while(a) b++;'
nl_while_leave_one_liners               = true    # false/true
# Don't split one-line OC messages
nl_oc_msg_leave_one_liner               = true    # false/true

# Add a newline between ')' and '{' if the ')' is on a different line than the if/for/etc.
# Overrides nl_for_brace, nl_if_brace, nl_switch_brace, nl_while_switch and nl_catch_brace.
nl_multi_line_cond                      = true
# Force a newline in a define after the macro name for multi-line defines.
nl_multi_line_define                    = true
# Whether to put a newline before 'case' statement, not after the first 'case'
nl_before_case                          = true
# Whether to put a newline after 'case' statement
nl_after_case                           = false
# Whether to put a blank line after 'return' statements, unless followed by a close brace.
nl_after_return                         = true
# Whether to put a newline after semicolons, except in 'for' statements
nl_after_semicolon                      = true
# Whether to put a newline after brace open.
# This also adds a newline before the matching brace close.
nl_after_brace_open                     = false
# If nl_after_brace_open and nl_after_brace_open_cmt are true, a newline is
# placed between the open brace and a trailing single-line comment.
nl_after_brace_open_cmt                 = false
# Whether to put a newline after a virtual brace open with a non-empty body.
# These occur in un-braced if/while/do/for statement bodies.
nl_after_vbrace_open                    = false
# Whether to put a newline after a virtual brace open with an empty body.
# These occur in un-braced if/while/do/for statement bodies.
nl_after_vbrace_open_empty              = false
# Whether to put a newline after a brace close.
# Does not apply if followed by a necessary ';'.
nl_after_brace_close                    = false
# Whether to put a newline after a virtual brace close.
# Would add a newline before return in: 'if (foo) a++; return;'
nl_after_vbrace_close                   = false
# Whether to alter newlines in '#define' macros
nl_define_macro                         = false
# Whether to remove blanks after '#ifxx' and '#elxx', or before '#elxx' and '#endif'. Does not affect top-level #ifdefs.
nl_squeeze_ifdef                        = false
# Whether to double-space commented-entries in struct/union/enum
nl_ds_struct_enum_cmt                   = false
# force nl before } of a struct/union/enum
# (lower priority than 'eat_blanks_before_close_brace')
nl_ds_struct_enum_close_brace           = false
# Change simple unbraced if statements into a one-liner
# 'if(b)\n i++;' => 'if(b) i++;'
nl_create_if_one_liner                  = true
# Change simple unbraced for statements into a one-liner
# 'for (i=0;i<5;i++)\n foo(i);' => 'for (i=0;i<5;i++) foo(i);'
nl_create_for_one_liner                 = true
# Change simple unbraced while statements into a one-liner
# 'while (i<5)\n foo(i++);' => 'while (i<5) foo(i++);'
nl_create_while_one_liner               = true
# Whether to fully split long 'for' statements at semi-colons
ls_for_split_full                       = false
# Whether to fully split long function protos/calls at commas
ls_func_split_full                      = false
# Whether to split lines as close to code_width as possible and ignore some groupings
ls_code_width                   = false    # false/true
# Whether to force a newline after a multi-line comment.
nl_after_multiline_comment              = true
# Whether to remove blank lines after '{'
eat_blanks_after_open_brace             = true
# Whether to remove blank lines before '}'
eat_blanks_before_close_brace           = true
# Make all if/elseif/else statements in a chain be braced or not. Overrides mod_full_brace_if.
# If any must be braced, they are all braced.  If all can be unbraced, then the braces are removed.
mod_full_brace_if_chain                 = true
# Whether to change optional semicolons to real semicolons
mod_pawn_semicolon                      = false
# Add parens on 'while' and 'if' statement around bools
mod_full_paren_if_bool                  = true
# Whether to remove superfluous semicolons
mod_remove_extra_semicolon              = false
# If TRUE, will sort consecutive single-line 'import' statements [Java, D]
mod_sort_import                         = false
# If TRUE, will sort consecutive single-line 'using' statements [C#]
mod_sort_using                          = false
# If TRUE, will sort consecutive single-line '#include' statements [C/C++] and '#import' statements [Obj-C]
# This is generally a bad idea, as it may break your code.
mod_sort_include                        = false
# If TRUE, it will move a 'break' that appears after a fully braced 'case' before the close brace.
mod_move_case_break                     = false
# If TRUE, it will remove a void 'return;' that appears as the last statement in a function.
mod_remove_empty_return                 = true
# If false, disable all multi-line comment changes, including cmt_width. keyword substitution and leading chars.
# Default=True.
cmt_indent_multi                        = true
# Whether to group c-comments that look like they are in a block
cmt_c_group                             = false
# Whether to put an empty '/*' on the first line of the combined c-comment
cmt_c_nl_start                          = false
# Whether to put a newline before the closing '*/' of the combined c-comment
cmt_c_nl_end                            = false
# Whether to group cpp-comments that look like they are in a block
cmt_cpp_group                           = false
# Whether to put an empty '/*' on the first line of the combined cpp-comment
cmt_cpp_nl_start                        = false
# Whether to put a newline before the closing '*/' of the combined cpp-comment
cmt_cpp_nl_end                          = false
# Whether to change cpp-comments into c-comments
cmt_cpp_to_c                            = false
# Whether to put a star on subsequent comment lines
cmt_star_cont                           = false
# For multi-line comments with a '*' lead, remove leading spaces if the first and last lines of
# the comment are the same length. Default=True
cmt_multi_check_last                    = true
# If a preprocessor is encountered when stepping backwards from a function name, then
# this option decides whether the comment should be inserted.
# Affects cmt_insert_oc_msg_header, cmt_insert_func_header and cmt_insert_class_header.
cmt_insert_before_preproc               = false

# Spaces to indent single line ('//') comments on lines before code
indent_sing_line_comments               = 0
# Spaces to indent 'case' from 'switch'
# Usually 0 or indent_columns.
indent_switch_case                      = 4
# Spaces to shift the 'case' line, without affecting any other lines
# Usually 0.
indent_case_shift                       = 0
# Whether to indent the code between #region and #endregion
pp_region_indent_code=false

# The span for aligning variable definitions (0=don't align)
align_var_def_span=0
# How to align the star in variable definitions.
#  0=Part of the type     'void *   foo;'
#  1=Part of the variable 'void     *foo;'
#  2=Dangling             'void    *foo;'
align_var_def_star_style                = 0
# How to align the '&' in variable definitions.
#  0=Part of the type
#  1=Part of the variable
#  2=Dangling
align_var_def_amp_style                 = 1
# The threshold for aligning variable definitions (0=no limit)
align_var_def_thresh                    = 0        # number
# The gap for aligning variable definitions
align_var_def_gap                       = 0        # number
# The span for aligning on '=' in assignments (0=don't align)
align_assign_span                       = 1

align_assign_thresh                     = 8
align_enum_equ_span                     = 3
align_var_struct_span                   = 3
align_var_struct_gap                    = 1
align_struct_init_span                  = 2
align_right_cmt_span                    = 2
align_right_cmt_gap                     = 1
align_right_cmt_at_col                  = 2

nl_end_of_file_min                      = 1
nl_func_var_def_blk                     = 1
nl_after_func_body                      = 2
nl_after_func_body_one_liner            = 2
nl_before_block_comment                 = 2

nl_after_struct                         = 1
mod_full_brace_nl                       = 1
mod_add_long_function_closebrace_comment= 32
mod_add_long_ifdef_endif_comment        = 10
mod_add_long_ifdef_else_comment         = 10
sp_arith                                = force
sp_assign                               = force

sp_assign_default                       = add
sp_enum_assign                          = force
sp_bool                                 = force
sp_compare                              = force
sp_before_ptr_star                      = remove
sp_before_unnamed_ptr_star              = remove
sp_between_ptr_star                     = remove
sp_after_ptr_star                       = add
sp_after_ptr_star_func                  = force
sp_before_ptr_star_func                 = force
sp_after_type                           = force
sp_before_sparen                        = force
sp_inside_sparen                        = remove
sp_after_sparen                         = add
sp_sparen_brace                         = add
sp_special_semi                         = remove
sp_before_semi                          = remove
sp_before_semi_for_empty                = remove
sp_after_semi                           = add
sp_after_semi_for_empty                 = remove
sp_after_comma                          = force
sp_before_comma                         = remove
sp_before_case_colon                    = remove
sp_after_operator                       = add
sp_after_operator_sym                   = add
sp_after_cast                           = add
sp_inside_paren_cast                    = remove
sp_sizeof_paren                         = remove
sp_inside_braces_enum                   = add
sp_inside_braces_struct                 = add
sp_inside_braces                        = add
sp_inside_braces_empty                  = add
sp_func_proto_paren                     = remove
sp_func_def_paren                       = remove
sp_inside_fparens                       = remove
sp_inside_fparen                        = remove
sp_fparen_brace                         = remove
sp_func_call_paren                      = remove
sp_func_call_paren_empty                = remove
sp_func_call_user_paren                 = remove
sp_return_paren                         = add
sp_attribute_paren                      = remove
sp_defined_paren                        = remove
sp_macro                                = add
sp_macro_func                           = add
sp_else_brace                           = add
sp_brace_else                           = add
sp_brace_typedef                        = add
sp_not                                  = remove
sp_inv                                  = remove
sp_addr                                 = remove
sp_member                               = force
sp_deref                                = remove
sp_sign                                 = remove
sp_incdec                               = remove
sp_before_nl_cont                       = add
sp_cond_colon                           = force
sp_cond_question                        = force
sp_cmt_cpp_start                        = add
sp_before_dc                            = remove
sp_after_dc                             = remove

nl_start_of_file                        = remove
nl_end_of_file                          = force
nl_assign_brace                         = remove
nl_assign_square                        = remove
nl_enum_brace                           = remove
nl_struct_brace                         = remove
nl_union_brace                          = remove
nl_if_brace                             = remove
nl_brace_else                           = remove
nl_elseif_brace                         = remove
nl_else_brace                           = remove
nl_else_if                              = remove
nl_for_brace                            = remove
nl_while_brace                          = remove
nl_do_brace                             = remove
nl_brace_while                          = remove
nl_switch_brace                         = remove
nl_case_colon_brace                     = remove
nl_func_type_name                       = remove
nl_func_proto_type_name                 = add
nl_func_paren                           = remove
nl_func_def_paren                       = remove
nl_func_decl_empty                      = remove
nl_func_def_empty                       = remove
# Add or remove newline between function signature and '{'
nl_fdef_brace                           = remove
nl_return_expr                          = remove
pos_arith                               = lead
pos_assign                              = trail
pos_bool                                = trail
pos_conditional                         = trail
pos_comma                               = trail
pos_class_comma                         = lead
pos_class_colon                         = lead
mod_full_brace_do                       = remove
mod_full_brace_for                      = remove
mod_full_brace_function                 = force
mod_full_brace_while                    = remove
mod_paren_on_return                     = ignore

# Misc
# --------------------------------------------------------------------------------------------------

# Allow interpreting '>=' and '>>=' as part of a template in 'void f(list<list<B>>=val);'.
# If true (default), 'assert(x<0 && y>=3)' will be broken.
# Improvements to template detection may make this option obsolete.
tok_split_gte                           = false

disable_processing_cmt="@rst"
enable_processing_cmt="@endrst"
